### 加密
加密一般分为 对称加密 和 非对称加密

对称加密 常用 比如DES 其性能比较好 但是会有密钥窃取的风险

非对称加密 RSA ECDH 包含公钥和私钥 安全性强 但是开销大

一般会使用 混合加密 即 用非对称加密 交换一个对称密钥 

### 公钥和私钥匙的作用
1. 公钥加密 私钥解密 RSA
2. 私钥签名 公钥验证 CA

### 混合加密的问题
混合加密无法解决中间人攻击的问题，需要CA

### CA 权威机构
网站向CA获取认证，CA证书中一般包含
- 网站的公钥
- 签发机构
- 签发机构私钥的签名
- 签发的网站

浏览器收到证书之后，会去一层层的查找证书链
注意 机构的公钥不在证书内，需要去下载或者去操作系统查找
证书链的根证书 内置在浏览器或者操作系统内 只有整条证书链验证完成，才能检验通过

### HTTPS
HTTPS = HTTP + TLS 传输层安全协议 /SSL 安全套接字协议
TLS/SSL 是表示层协议

### TLS 1.2 / 1.3
TLS1.2 采用 RSA / ECDH 算法 通讯双方需要协商密码套件
握手需要2次RTT 
- 客户端携带客户端参数 请求服务端的证书
- 服务端返回证书和服务端参数
- 客户端生成 Pre-Master Key 通过 服务端的公钥加密 传递给服务端
- 客户端和服务端共同使用 Pre-Master Key 服务端参数 客户端参数 计算出 Master key , Session Key 
- 协商结束 双方使用session key 通讯

问题: RSA 需要2次RTT 并且没有前向安全 
如果服务端泄漏了私钥 并且截获了 双方参数和公钥加密后的pre-master key 就能推出 session key 从而揭开数据

TLS1.3 精简了密码套件 使用ECDH算法
1.2的问题在于，pre-master key 需要在网络上传递，1.3的pre-master 通过双方计算
- 客户端生成一个服务端私钥 client private key 并且通过椭圆曲线计算 * G 获得client public key
- 客户端把 客户端公钥和客户端参数发给服务器 服务器也生成一个server private key 并且通过椭圆曲线计算 * G 获得server public key 并且将其和服务端参数 证书 发给客户端
- 客户端用 client private key * server public key  = pre master-key 
- 服务端用 server private key * client public key = pre-master key 双方pre-master key 一样
- 通过参数 计算 master key 和 session key

好处 之需要一次RTT 并且保证前向安全
因为只有双方公钥传输了，而私钥从来没传输，当会话结束，私钥被在内存中 被销毁
1.3的证书只有验证的作用 其中的公钥没用
这种方式就能保证历史数据永远不会被解开

