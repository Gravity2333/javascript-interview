## ES6版本的作用域

### 老版本的作用域
```
VO (GO AO) 
作用域链的概念
EC = VO + this binding + Scope
无法解释 块作用域
```


### ES6版本的作用域
```
EC 包含: EC包含两个指针 VE VariableEnvironment 变量环境指针 LE LexicalEnvironment 词法环境指针 + This binding
这两个指针 默认共同指向EC对应的词法环境

词法环境分成 全局词法环境 函数词法环境 块词法环境

词法环境内部 包含环境记录器 和 outer outer指向外层的词法环境 全局词法环境的outer为null 函数词法环境的outer为函数对象的[[scope]]

环境记录器Environment Record (ER) 包含 
DER 声明式环境记录器 类似Map
OER 对象式环境记录器 类似Object

其中 全局词法环境 包含 DER和OER OER也就是window/global
函数词法环境/块词法环境 包含DER

全局作用域下  var 顶级的function let const 都会放到DER 且 var 顶级function会同步加入OER 这也是为什么window.xx可以访问var或者顶级function

直接使用 a= 10 会直接加入到OER 不会加入到DER

函数中，全局的var 顶级的function let const 会放到函数词法环境的DER

当 函数/全局中 出现 {} 块
会创建一个块词法环境，LE会指向这个块词法环境
块词法环境的outer为创建块的词法环境
EC的LE会指向这个块词法环境！

块内的let const class function 都会放到块词法环境的DER中，但是var是放到上层的函数/全局词法环境的DER中的

块中的const class function 在块结束后 就会销毁，但是在非严格模式下 function会被挂到最最近的函数/全局词法环境的DER 这是个兼容性处理，但是如果外层包含了let const 就没有这个处理了!

const let 之间不能同名
const let 和 var function也不能同名
块内的function你可以当作let声明的 所以块内的function也不能和var 一起声明
{

    var A
    function A(){} // ERR 
    等价 let A = function(){}
}

```

### TDZ 
```
对于 let const 也会提升，但是会赋值
console.log(a);
let a = 1;
Uncaught ReferenceError: can't access lexical declaration 'a' before initialization
    <anonymous> debugger eval code:1
本质上是 let const class 提升之后，不会赋值 其状态为 uninitialize
目的就是规范let const class 的使用 在定义之前 不能使用 
```

### 闭包
一个函数可以记住自己创建时的词法环境，在任意位置调用的时候 ，都可以访问到这个词法环境
