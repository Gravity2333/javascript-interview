### 原型链

```
现有
Object.prototype
Function.prototype

Object.prototype.__proto__ = null
Function.prototype.__proto__ = Object.prototype.__proto__
Function.prototype 是个函数

再有 Function
Function.prototype = Function.prototype
Function.__proto__ = Function.prototype

Object.prototype = Object.prototype
Object.__proto__ = Function.prototype (Object 也是个函数)

任意对象字面量 . __proto__ = Object.prototype
普通函数 foo.__proto__ =  Function.prototype
foo.prototype = foo.prototype
foo.prototype.__proto__ = Object.prototype
```

## **proto**

**proto** 不是标准 而是事实约定
标准规定 需要使用 Object.getProtypeOf / Object.setPrototypeOf 来设置原型

## new

```
new做了什么
1. 创建一个对象
2. 把这个对象的__proto__ 设置为构造函数的 prototype
3. 执行函数体 绑定this
4. 如果返回普通类型 则返回这个对象 否则返回函数体的返回值
```

new > bind

### 函数对象

函数对象创建过程

1. 创建一个函数对象
2. 创建一个原型对象 把函数对象的 prototype 设置给原型 原型的.constructor 设置给函数对象
3. 函数对象 fn 的[[scopes]]内部属性 指向当前执行上下文的词法环境
4. 设置形式参数长度 length 函数名字 name

### 相关方法 Object.create

Object.create(target) 把 target 作为原型创建一个对象

### Reflect.get Reflect.set

```
get操作过程 LHS
找当前对象 有无属性
找原型有无属性
如果找到null 还是没有 返回undefined


set 操作过程。RHS
找当前对象和原型 如果直到null
如果找不到 就在对象本身创建属性
如果找到
 1. 如果是基本类型 则在对象时创建覆盖
 2. 如果复杂类型 的引用修改 则在对象上创建覆盖
 3. 如果复杂类型属性的修改 那么直接修改
```

### 题目

题目 阿里四面 （把原型链画出来!）

```javascrpt
        Object.prototype.a = function(){
            console.log('a')
        }
        Function.prototype.b = function(){
            console.log('b')
        }
        var F = function(){}
        var f = new F()
        f.a() // a
        f.b() // b 在Function.prototype 找不到Err
        F.a() // a
        F.b() // b
```

例子 - 1

```javascrpt
const obj = {
a: 100,
b: {
    c: 300
    }
}
obj.__proto__.foo=function () {
console.log('foo')
}
obj.__proto__.test = {
value: 0
}
```

```javascrpt
1. 对 obj 进行 LHS 给一个不存在的属性 z 赋值
   obj.z=100
   对对象本身[[PUT]] z 是基本类型，覆盖
   obj = {
   a: 100,
   b: {
   c: 300
   }，
   z:100,
   }
```

```javascrpt
2. 对 obj 进行 LHS 给一个存在的普通类型赋普通值
obj.z= 200
[[PUT]] 普通类型 直接原对象修改
a: 100,
b: {
c: 300
}，
z:200,
}
```

3. 给原型上的属性重赋引用值

```javascrpt
   obj.foo = ()=>"new Func"
   [[PUT]] 对复杂类型引用的修改
   obj = {
   a: 100,
   b: {
   c: 300
   },
   foo: ()=>"new Func"
   }
```

例子 2
```javascrpt
function A(){}
A.prototype.n = 3
A.prototype.add = function(){ this.n++ }
const a = new A()
const b = new A()
const c = new A()
a.add()
b.add()
console.log(a.n,b.n,c.n)
```
function A(){} --- prototype ---> A.prototype n: 3
add: function(){ this.n++ }

a ---**proto** ---> A.prototype
b ---**proto** ---> A.prototype
c ---**proto** ---> A.prototype

a.add 此时 this 是对象 a，由于 n 在原型上，所以会直接在 a 对象上创建 n = 4 覆盖
b.add 同理
所以最后结果
4 a 对象上的 n
4 b 对象上的 n
3 A.prototype 上的 n

例子 3
```javascrpt
function A(){}
A.prototype.n = {t:1}
A.prototype.add = function(){ this.n = {} }
const a = new A()
a.add()
console.log(a.n.t)
```
n 在原型上，并且 add 是对复杂类型引用的修改，在 a 对象上添加了一个 n 进行覆盖
所以 a.n.t 为 undefined

例子 4
```javascrpt
function A(){}
A.prototype.n = {t:1}
A.prototype.add = function(){ this.n.t++}
const a = new A()
a.add()
console.log(a.n.t)
```
这个是对原型上复杂类型属性的修改，不是修改引用，此时会直接修改属性值，不覆盖，此时 a.n.t = 2

￼
1 3 4 1 2 undefined (把图画出来)
￼
